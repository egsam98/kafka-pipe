// Code generated by Warden. DO NOT EDIT.

package kafkapipe

import (
	warden "github.com/egsam98/warden"
	"net/url"
	"strconv"
)

func (self *ProducerConfig) Validate() error {
	var errs warden.Errors
	if len(self.Brokers) == 0 {
		errs.Add("brokers", warden.Error("must be non empty"))
	}
	errs.Add("brokers", func() error {
		var errs warden.Errors
		for i, elem := range self.Brokers {
			if _, err := url.Parse(elem); err != nil {
				errs.Add(strconv.Itoa(i), warden.Error("must be URL"))
			}
		}
		return errs.AsError()
	}())
	errs.Add("topic", func() error {
		self := &self.Topic
		var errs warden.Errors
		if self.ReplicationFactor == 0 {
			self.ReplicationFactor = 1
		}
		if self.Partitions == 0 {
			self.Partitions = 1
		}
		if self.CleanupPolicy == "" {
			self.CleanupPolicy = "delete"
		}
		if self.CompressionType == "" {
			self.CompressionType = "producer"
		}
		if self.Retention == 0 {
			self.Retention = 604800000000000 // 168h
		}
		if self.PartRetentionSize == "" {
			self.PartRetentionSize = "10GB"
		}
		return errs.AsError()
	}())
	errs.Add("batch", self.Batch.Validate())
	return errs.AsError()
}

func (self *ConsumerPoolConfig) Validate() error {
	var errs warden.Errors
	if self.Group == "" {
		errs.Add("group", warden.Error("required"))
	}
	if len(self.Brokers) == 0 {
		errs.Add("brokers", warden.Error("must be non empty"))
	}
	errs.Add("brokers", func() error {
		var errs warden.Errors
		for i, elem := range self.Brokers {
			if _, err := url.Parse(elem); err != nil {
				errs.Add(strconv.Itoa(i), warden.Error("must be URL"))
			}
		}
		return errs.AsError()
	}())
	if len(self.Topics) == 0 {
		errs.Add("topics", warden.Error("must be non empty"))
	}
	if self.RebalanceTimeout == 0 {
		self.RebalanceTimeout = 60000000000 // 1m
	}
	if self.WorkersPerTopic == 0 {
		self.WorkersPerTopic = 1
	}
	errs.Add("batch", self.Batch.Validate())
	return errs.AsError()
}

func (self *BatchConfig) Validate() error {
	var errs warden.Errors
	if self.Size == 0 {
		self.Size = 10000
	}
	if self.Timeout == 0 {
		self.Timeout = 5000000000 // 5s
	}
	return errs.AsError()
}
